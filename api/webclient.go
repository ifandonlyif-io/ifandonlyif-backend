package api

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/go-resty/resty/v2"
	_ "github.com/ifandonlyif-io/ifandonlyif-backend/docs" // docs is generated by Swag CLI, you have to import it.
	"github.com/labstack/echo/v4"
	"github.com/robfig/cron/v3"
)

type GasPrices struct {
	Average string `json:"result"`
}

type GasInfo struct {
	Average   string `json:"average"`
	CreatedAt string `json:"createdAt"`
}

func (server *Server) RunCronFetchGas() {
	// Create a Resty Client
	client := resty.New()

	cronjob := cron.New()

	// cronjob.AddFunc("@hourly", func() {
	cronjob.AddFunc("* * * * *", func() {
		resp, err := client.R().
			EnableTrace().
			Get("https://api.etherscan.io/api?module=proxy&action=eth_gasPrice&apikey=4Y6CC9H78BT4KF4NZKU7FU2Z3XA3CC4QE7")

		if err != nil {
			fmt.Println("No response from request")
		}

		var gp GasPrices

		if errJson := json.Unmarshal(resp.Body(), &gp); errJson != nil { // Parse []byte to the go struct pointer
			fmt.Println("Can not unmarshal JSON")
		}
		// use the parseInt() function to convert

		averagePrice, errHex := strconv.ParseInt(hexaNumberToInteger(gp.Average), 16, 64)

		// in case of any error
		if errHex != nil {
			fmt.Println("Can not convert Hex!!")
		}
		var gWei float64 = float64(averagePrice) / 10000000000
		gWeiText := fmt.Sprintf("%.2f", gWei)

		createGas, dberr := server.store.CreateGasPrice(context.Background(), sql.NullString{String: gWeiText, Valid: true})
		if dberr != nil {
			return
		}
		fmt.Println("cron times : ", createGas)

	})

	cronjob.Start()

}

// gasInfo godoc
// @Summary      gasInfo
// @Description  get every minutes gas prices
// @Tags         gasInfo
// @Accept */*
// @produce application/json
// @Success      200  {string}  StatusOK
// @Router       /gasInfo [GET]
func (server *Server) GasHandler(c echo.Context) (err error) {
	getGasInfo, err := server.store.GetAveragePriceByLastDay(context.Background())
	if err != nil {
		return echo.NewHTTPError(http.StatusUnauthorized, err)
	}

	var newGasInfo []GasInfo

	for i := 0; i < len(getGasInfo); i++ {
		field := getGasInfo[i]
		if field.Average.Valid && field.CreatedAt.Valid {
			newGasInfo = append(newGasInfo, GasInfo{Average: field.Average.String, CreatedAt: field.CreatedAt.Time.Format(time.RFC3339)})
		}
		fmt.Print(newGasInfo)
	}

	return c.JSON(http.StatusAccepted, newGasInfo)
}

func hexaNumberToInteger(hexaString string) string {
	// replace 0x or 0X with empty String
	numberStr := strings.Replace(hexaString, "0x", "", -1)
	numberStr = strings.Replace(numberStr, "0X", "", -1)
	return numberStr
}
